{
  "name": "connect-four",
  "version": "0.0.6",
  "description": "Lightweight connect-four game logic",
  "main": "src/index.js",
  "scripts": {
    "test": "mocha test/index.js",
    "build": "webpack --watch"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@gitlab.com/PsychoLlama/connect-four.git"
  },
  "keywords": [
    "connect-four",
    "game-logic"
  ],
  "author": {
    "name": "Jesse Gibson",
    "email": "jesse@gundb.io",
    "url": "http://techllama.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://gitlab.com/PsychoLlama/connect-four/issues"
  },
  "homepage": "https://gitlab.com/PsychoLlama/connect-four#README",
  "devDependencies": {
    "chai": "^3.5.0",
    "eslint": "^2.9.0",
    "mocha": "^2.4.5"
  },
  "readme": "# Connect-four\n\nSimple game logic featuring \"connect-four\".\n\n## Why\nI work for [gunDB](http://gun.js.org/#step1), and we're building a cool database in Javascript. To showcase some of the real-time collaborative goodness, I've made a connect-four game, which you can try [here](http://c4.gundb.io). All the app code is [open source](https://github.com/PsychoLlama/connect-four), so feel free to poke through for a working example :wink:\n\n&lt;/shameless-self-promotion&gt;\n\nInstead of hard coding the game logic, I figured I'd produce it as a separate npm module that other people can use.\n\n## Usage\n\nIf you haven't installed it, you can do so on [npm](https://www.npmjs.com/package/connect-four):\n\n```bash\n$ npm install connect-four\n```\n\nNow you should be able to `require` it from [Node.js](https://nodejs.org/en/) by placing this in a file:\n\n```Javascript\nvar Game = require('connect-four');\n```\n\n> connect-four is webpack/browserify friendly.\n\nConnect-four exports a game constructor. You can create a new game by running\n\n```Javascript\nvar myGame = new Game();\n```\n\nThe constructor takes an options object with some configuration things.\n\n### Options\n - `rows`: the number of rows in the game.\n - `cols`: the number of columns in the game.\n - `board`: an existing board from a previous game (through something like localStorage).\n\nIf you don't pass any options, they'll be filled with these defaults:\n\n| cols | rows | board |\n|:----:|:----:|:-----:|\n|  7   |  6   |  `{}` |\n\nThe board is a record of all turns and players, and is filled using [`.play`](#play).\n\n## Events\nThe `Game` class extends [`EventEmitter`](https://nodejs.org/api/events.html) from node's core library. Here are some useful events you can listen for:\n\n - `play`: the game has just taken another turn. You're passed 3 arguments:\n\t- `player`, the unique string identifier.\n\t- `coords`, an object containing the `row` and `col` properties.\n\t- `game`, the instance the event was fired on.\n - `end`: the game has just ended. You're passed two arguments:\n\t- `winner`, the unique ID of the player who won.\n\t- `game`, the instance the event fired on.\n\n**Example**\n```Javascript\nvar game = new Game()\ngame.on('play', function (player, coord) {\n\tview.message('Player \"' + player + '\" finished their turn.')\n\tvar color = view.getPlayerColor(player)\n\tview.board.set(coord, color)\n});\n```\n\n## Methods\n\n### <a name='play'></a> .play(player, column)\nThis is the equivalent of dropping a token into a slot. Be warned though, if you try to place a token in a column that's already full, you'll get a nasty error. Use [`validMove()`](#validMove) to check first (it'll also make sure it's within the game boundaries).\n\nThe first parameter, `player`, is a unique string identifying the user who placed the token. What string you use is left up to you, just make sure it's consistent.\n\nThe second parameter is the column to place the token into. For instance, if your board is 7 columns wide, calling `.play('green', 3)` will drop the token into column 3 (starting from zero) and index it as player 'green'.\n\n### <a name='get'></a> .get(column, row)\nThis method retrieves the name of the player who placed the token there. The name is the unique ID you chose when calling [`.play`](#play).\n\n### <a name='validMove'></a> .validMove(column)\nThis method returns a boolean value. If you've entered a column that is either full or out of bounds, this method will return `false`, not a valid move. Otherwise it returns `true`.\n\n### <a name='end'></a> .end(player)\nEnds the game and sets the winner. If there is no winner, it defaults to `null`. This method will only work once per instance, and won't fire an `end` event twice. This all happens under the hood though, since wins and ties are automatically detected. However, if you ever need it, you know where to find it.\n\n### <a name='ended'></a> .ended\nA simple boolean property telling whether the game has ended or not.\n\n### <a name='winner'></a> .winner\nA string representing the match winner. If the game hasn't ended yet, it'll be `null`.\n\n### <a name='cells'></a> .cells\nA number representing the remaining spaces left. If that number hits zero, a tie is called and `null` is the grand victor.\n\n\n## Examples\n\n**Simple game**\n```Javascript\nvar Game = require('connect-four')\nvar game = new Game()\ngame.play('green', 0)\ngame.play('green', 1)\ngame.play('green', 2)\ngame.play('green', 3)\n// `end` event fires, 'green' wins\n```\n\n**More complex game**\n```Javascript\nvar Game = require('connect-four')\nvar game = new Game({\n\trows: 5,\n\tcols: 10\n})\n\ngame.play('red', 0);\ngame.play('green', 1);\ngame.play('red', 0);\ngame.play('green', 2);\ngame.play('red', 0);\ngame.play('green', 3);\ngame.play('red', 0);\n// game ends, 'red' wins (vertically)\n\nconsole.log(game.winner) // 'red'\nconsole.log(game.ended) // true\n```\n\n## Support\nIf you have any questions or issues, ping us in the [gitter channel](https://gitter.im/amark/gun).\n\nThanks for checking out the project!\n",
  "readmeFilename": "README.md",
  "_id": "connect-four@0.0.6",
  "_from": "connect-four@"
}
